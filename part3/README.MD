# Part 3: Production Build and Testing
So far, we've defined a project build that should only be used in development. Let's create a usable production build that minifies our code and excludes any unnecessary libraries, such as Hot-Reloading. Let's also modify our dev server so it can be used for both development and production!

Next, let's add a testing framework to our application so we can be sure our code is solid when it gets deplolyed to production!

## Milestone 1: Splitting the build
So far, we've had only one config file for our build - the development build. Let's modify our config to support production as well! Let's also split out our framework code from our application code during the build. We do this in order to cache the framework code on the client's browser so we don't have to pull it in every time they visit our app! This will lead to a significantly smaller download for our users on subsequent loads of our website.

Let's organize our configs inside a 'config' folder. In the root of our app, create a *config* folder and create three files:
* *webpack.base.config.js*
* *webpack.development.config.js*
* *webpack.production.config.js*

In *webpack.base.config.js*, we will house all of our base configuration shared between development and production. To help us merge these configurations easier, let's install **webpack-merge**:

```
npm install --save-dev webpack-merge
```

In *webpack.base.config.js*, let's copy over what we had from our old *webpack.config.js* and modify it a bit to look like this:

```

```

### webpack.base.config.js
Note that we have an `entry` called 'vendor'. This is where we will house all of our framework code needed to run the app on the browser. It currently contains the React, ReactDOM, and React-Router libraries. If we add any more libraries needed to run our application, we should add them here. When the build is finished, it will output a file called *vendor.[generated_hash].js* containing all of our framework code.

We removed 'app' from our base config so that the specific environment configurations define their own. This is because we need to add a few entry points in development so that HMR works correctly, while production won't need them. However, both development and production will share the same framework code, so we abstract that out here in the base config.

'output' contains only the publicPath for the server, which should stay the same for both dev and prod.

The 'module' sections remains the same as the one in our old *webpack.config.js*. We need the same loaders in both dev and prod.

Our `plugins` array, however, looks a bit different. We've removed the HotModuleReplacementPlugin because we only need it in development. However, the rest of the plugins should be the same as our old config, save for one. We include the NamedModulesPlugin to get around how Webpack combines modules behind the scenes. It defaults to giving modules integer ids. If a module is changed, it's possible that all the ids change too and causes the cache to become invalid. NamedModulesPlugin makes it so Webpack chooses ids in a predictable way.

### webpack.development.config.js
```

```

Our development config is now very simple. It includes a 'devtool' entry, which allows us to see the original code when we debug so we get the benefit of line numbers.

It includes the same 'entry' config as our original *webpack.config.js* file, which contains the entry points needed for HMR. Output is the same as the our original webpack config, but note that we've change the relative path of the dev folder (so that it ends up in the root of the app, not the config folder).

In our plugins array we've included HotModuleReplacementPlugin so that HMR is enabled in Webpack. Note the use of 'webpackMerge' in the export. This will simply merge our baseConfig with the development config we've defined here.

### webpack.production.config.js
```
```
Our production config contains a similar entry to our development, but without the HMR dependencies.

Our 'output' section has changed a bit. 'path' will create a folder to output the generated files because we don't use Webpack-Dev-Middleware in production, so the files aren't stored in memory. They'll need to be written to disk. We modified `filename` to use `[chunkHash:8]` rather than `[hash]`. We've also added a section called `chunkFilename` that looks like '[name].[chunkHash:8].chunk.js'. Originally, we were using `[hash]`, which is the hash for the whole compilation. That meant if we changed any file, the compilation hash will be different. Now that we've separated out the 'vendor' section, the hash of the compilation is no longer useful to us because if we change a single line of application, all the files will get a new hash, even though the framework code was not touched.

Now, we're using 'chunkHash'. This is the hash for the 'chunk' of code that is generated by Webpack. That scopes the hash to only the file we care about. So, if we make changes to our app code, only the hash of the app code will change. Even cooler, since Webpack generates 'chunks' for each of our dynamic routes, if we only change the code for one of the dynamic routes, only that chunk will change have a new hash the next time we build. This completely isolates sections of the code and the browser will only update what it needs! The ':8' at the end of chunkHash basically truncates the hash so the file name is shorter (for readability).

It includes a few more plugins:

* LoaderOptionsPlugin
* UglifyJSPlugin is used for minifying the code. See [here](https://davidwalsh.name/compress-uglify) for more info about the included parameters.
* CommonsChunkPlugin is used for preventing duplication across the modules that Webpack splits out for us. Note that the 'vendor' chunk includes the Webpack manifest, which maps chunk ids to hashes. Whenever any module changes, the side effect is that entry pointâ€™s hash will change too. This invalidates our cached vendor chunk every time we make a change to our app. To fix this, we pull out 'manifest' into its own chunk here in the config.
* InlineManifestWebpackPlugin is used to prevent another HTTP request to get the manifest. To get this to work correctly, we need to modify our rename our *index.html* to

http://survivejs.com/webpack/building-with-webpack/splitting-bundles/
https://medium.com/connect-the-dots/caching-assets-long-term-with-webpack-5ad24a4c39bd#.tait28bt2
https://webpack.js.org/guides/migrating/#code-splitting-with-es2015
https://medium.com/@addyosmani/progressive-web-apps-with-react-js-part-2-page-load-performance-33b932d97cf2#.jszlsxib4
